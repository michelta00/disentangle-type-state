---
title: "Scores"
author: "Michel Tarnow"
date: today
format: 
    html:
      toc: true
      self-contained: true
      highlight-style: github
      code-line-numbers: true
editor_options: 
    chunk_output_type: inline
---

## Import Packages

```{r}
suppressPackageStartupMessages({
  library(tidyverse)
  library(UpSetR)
})
```

## Load Data

### Patches Scores

```{r}
# read data from file and assign correct column names
patches_con <- read_csv(
  "../../data/sim/02-scores_patches/t100,s80,b0-patches_con_loadings.csv",
  col_names = TRUE,
  col_types = "cddd",
  name_repair = "minimal"
)
colnames(patches_con)[1] = "gene_id"


# add combinations of scores

## max absolute value
patches_con <- patches_con %>% 
  mutate(condition_score_Patches_max_abs = pmax(abs(Condition1_score_Patches), 
                                                abs(Condition2_score_Patches)))

## Euclidean norm
patches_con <- patches_con %>% 
  mutate(condition_score_Patches_eucl_norm = sqrt(Condition1_score_Patches^2 + 
                                                    Condition2_score_Patches^2))


head(patches_con)
```

```{r}
patches_clu_con <- read_csv(
  "../../data/sim/02-scores_patches/t100,s80,b0-patches_clu_con_loadings.csv",
  col_names = TRUE,
  col_types = "cddd",
  name_repair = "minimal"
)
colnames(patches_clu_con)[1] = "gene_id"


# add combinations of scores

## max absolute value
patches_clu_con <- patches_clu_con %>% 
  mutate(condition_score_Patches_max_abs = pmax(abs(Condition1_score_Patches), 
                                                abs(Condition2_score_Patches)),
         group_score_Patches_max_abs = pmax(abs(Group1_score_Patches),
                                            abs(Group2_score_Patches),
                                            abs(Group3_score_Patches)))

## Euclidean norm
patches_clu_con <- patches_clu_con %>% 
  mutate(condition_score_Patches_eucl_norm = sqrt(Condition1_score_Patches^2 + 
                                                    Condition2_score_Patches^2),
         group_score_Patches_eucl_norm = sqrt(Group1_score_Patches^2 +
                                                Group2_score_Patches^2 +
                                                Group3_score_Patches^2))


head(patches_clu_con)
```

### FSS Scores

```{r}
# read in RDS objects
# fss_tf_rds <- readRDS("../../data/sim/02-scores_fss/sco-t100,s80,b0,tF.rds")
# fss_pve_rds <- readRDS("../../data/sim/02-scores_fss/sco-t100,s80,b0,PVE.rds")
# fss_spbds_rds <- readRDS("../../data/sim/02-scores_fss/sco-t100,s80,b0,sPBDS.rds")
# fss_hvg_rds <- readRDS("../../data/sim/02-scores_fss/sco-t100,s80,b0,HVG.rds")
# fss_random_rds <- readRDS("../../data/sim/02-scores_fss/sco-t100,s80,b0,random.rds")
```

```{r}
# get all files containing FSS scores
rds_files <- list.files(
  "../../data/sim/02-scores_fss/",
  pattern = "\\.rds$", 
  full.names = TRUE
)

# select gene and score columns and combine all dfs in one list
fss_score_dfs <- lapply(rds_files, function(file) {
  
  # get df from file name
  df <- readRDS(file)
  
  # rename score value column to score name
  if (nrow(df) > length(unique(df$gene_id))) {
    # df contains both tPVE and sPVE scores
    df <- df %>% 
      pivot_wider(names_from = sco, values_from = sco_val)
    cols_to_keep <- c("gene_id", "tPVE", "sPVE")
  } else {
    # df contains a single score
    new_colname <- df$sco[1]
    df <- df %>% 
      rename(!!new_colname := sco_val)
    cols_to_keep <- c("gene_id", new_colname)
  }
  
  # select gene and score columns
  df <- df %>% 
    select(gene_id, all_of(cols_to_keep))
})

# combine all dfs in one df
fss_scores <- as_tibble(reduce(
  fss_score_dfs, 
  ~ inner_join(.x, .y, by = "gene_id")
))

head(fss_scores)
```

### Gene Metadata

```{r}
gene_md <- as_tibble(readRDS("../../data/sim/01-pro/t100,s80,b0-rd.rds")) %>% 
  select(gene_id, everything())

head(gene_md)
```

### Gene Ground Truths

Gene ground truths, i.e., whether a gene is considered a type or a state gene, can be obtained from the simulated data via the logFC of splatter's DE factor (e.g., `ConditionDE.Condition1` or `GroupDE.Group1` in gene metadata). A gene is considered DEnotDS if there is a group logFC unequal to 1 and no condition logFC unequal to 1. Similarly, a gene is considered DS if there is a condition logFC unequal to 1, regardless of group logFCs. DEnotDS genes are selected as ground truth type genes, while DS genes are selected for ground truth state genes, i.e., a type gene must have a group effect and no state effect, while a state gene must have a condition effect while a group effect is not necessary (but can exist).

Here, all selections from the FSS paper's workflow are loaded for the t100,s80,b0 experiment and combined. This includes the selection strategies based on simulation parameters (like DEnotDS and DS) as well as selection strategies based on feature scores. 

```{r}
# get all files containing selections
rds_files <- list.files(
  "../../data/sim/03-selections_fss/",
  pattern = "\\.rds$", 
  full.names = TRUE
)

# select gene and selection columns and combine all dfs in one list
fss_selection_dfs <- lapply(rds_files, function(file) {
  
  # get df from file name
  df <- readRDS(file)
  
  # df contains a single selection
  new_colname <- df$sel[1]
  df <- df %>% 
    rename(!!new_colname := sel_val)
  cols_to_keep <- c("gene_id", new_colname)
  
  # select gene and score columns
  df <- df %>% 
    select(gene_id, all_of(cols_to_keep))
})

# combine all dfs in one df
fss_selections <- as_tibble(reduce(
  fss_selection_dfs, 
  ~ inner_join(.x, .y, by = "gene_id")
))

# sort columns to put ground truths first
fss_selections <- fss_selections %>% 
  select(DEnotDS, DS, DSnotDE, DEgtDS, DSgtDE, DE, everything())

head(fss_selections)
```

## Compare Patches scores to gene ground truths

### Type Genes

```{r}
# get true type genes
true_tg <- (fss_selections %>% 
  filter(DEnotDS == TRUE) %>% 
  select(gene_id))$gene_id

# get the same number of predicted type genes via top-n Patches scores
nt <- length(true_tg)

t_abs <- rank(patches_clu_con$group_score_Patches_max_abs)
o_abs <- order(t_abs, decreasing = TRUE)
patches_tg_abs <- patches_clu_con$gene_id[o_abs[seq_len(nt)]]

t_eucl <- rank(patches_clu_con$group_score_Patches_eucl_norm)
o_eucl <- order(t_eucl, decreasing = TRUE)
patches_tg_eucl <- patches_clu_con$gene_id[o_eucl[seq_len(nt)]]

# compare overlap
gene_sets <- list(
  GroundTruth = true_tg,
  PatchesMaxAbs = patches_tg_abs,
  PatchesEuclNorm = patches_tg_eucl
)

upset(fromList(gene_sets),
      order.by = "freq",
      sets = c("GroundTruth", "PatchesMaxAbs"))
upset(fromList(gene_sets),
      order.by = "freq",
      sets = c("GroundTruth", "PatchesEuclNorm"))
```

### State Genes

```{r}
# get true state genes
true_sg <- (fss_selections %>% 
  filter(DS == TRUE) %>% 
  select(gene_id))$gene_id

# get the same number of predicted state genes via top-n Patches scores
nt <- length(true_sg)

t_abs <- rank(patches_clu_con$condition_score_Patches_max_abs)
o_abs <- order(t_abs, decreasing = TRUE)
patches_sg_abs <- patches_clu_con$gene_id[o_abs[seq_len(nt)]]

t_eucl <- rank(patches_clu_con$condition_score_Patches_eucl_norm)
o_eucl <- order(t_eucl, decreasing = TRUE)
patches_sg_eucl <- patches_clu_con$gene_id[o_eucl[seq_len(nt)]]

# compare overlap
gene_sets <- list(
  GroundTruth = true_sg,
  PatchesMaxAbs = patches_sg_abs,
  PatchesEuclNorm = patches_sg_eucl
)

upset(fromList(gene_sets),
      order.by = "freq",
      sets = c("GroundTruth", "PatchesMaxAbs"))
upset(fromList(gene_sets),
      order.by = "freq",
      sets = c("GroundTruth", "PatchesEuclNorm"))
```

## Compare Patches Scores to FSS Scores

```{r}
all_scores <- cbind.data.frame(
  fss_scores,
  patches_clu_con %>% 
    select(
      condition_score_Patches_max_abs,
      group_score_Patches_max_abs,
      condition_score_Patches_eucl_norm,
      group_score_Patches_eucl_norm,
      common_score_Patches
    )
)
```

```{r}
cor(all_scores$sPBDS, all_scores$group_score_Patches_max_abs, method = "spearman")
```


```{r}
ggplot(data = all_scores, mapping = aes(x = (tPVE - mean(tPVE)) / sd(tPVE), y = (group_score_Patches_max_abs - mean(group_score_Patches_max_abs)) / sd(group_score_Patches_max_abs))) +
  geom_point() +
  geom_smooth() +
  theme_minimal()
```































