---
title: "Scores-Selections Comparison"
author: "Michel Tarnow"
date: today
format: 
    html:
      toc: true
      self-contained: true
      highlight-style: github
      code-line-numbers: true
editor_options: 
    chunk_output_type: inline
---

## Import Packages

```{r}
suppressPackageStartupMessages({
  library(tidyverse)
  library(UpSetR)
  library(reshape2)
  library(MLmetrics)
})
```



## Scoring

Here, Patches scores produced by running the model on simulation data in Python are loaded from file and recombined into new ones. For example, scores for the different conditions (one score per condition) are combined into a single score by their max absolute value or by their Euclidean norm. FSS scores are loaded from file, which were obtained by running the snakemake workflow.

### Helper Functions

```{r}
# helper function for loading and processing Patches scores
load_process_patches_scores <- function(file) {
  
  # read in df from file and fix column names
  df <- read_csv(
    file,
    col_names = TRUE,
    name_repair = "minimal",
    show_col_types = FALSE
  )
  colnames(df)[1] = "gene_id"
  
  # add combinations of scores
  
  ## max absolute value for condition
  df <- df %>% 
    mutate(
      condition_score_max_abs_Patches = pmax(
        abs(Condition1_score_Patches),
        abs(Condition2_score_Patches)
      )
    )
  
  # Euclidean norm for condition
  df <- df %>% 
    mutate(
      condition_score_eucl_norm_Patches = sqrt(
        Condition1_score_Patches^2 +
          Condition2_score_Patches^2
      )
    )
    
  if ("Group1_score_Patches" %in% names(df)) {
    ## cluster and condition scores available
    
    # max absolute value for group
    df <- df %>% 
      mutate(
        group_score_max_abs_Patches = pmax(
          abs(Group1_score_Patches),
          abs(Group2_score_Patches),
          abs(Group3_score_Patches)
        )
      )
    
    # Euclidean norm for group
    df <- df %>% 
      mutate(
        group_score_eucl_norm_Patches = sqrt(
          Group1_score_Patches^2 +
            Group2_score_Patches^2 +
            Group3_score_Patches^2
        )
      )
    
  }
  
  return(df)
    
}

# helper function for loading and processing FSS scores
load_process_fss_scores <- function(files, hvgs) {
  
  # select gene and score columns and combine all dfs in one list
  dfs <- lapply(files, function(file) {
    
    # read in df from file
    df <- readRDS(file)
    
    # rename score value column to score name
    if (nrow(df) > length(unique(df$gene_id))) {
      # df contains both tPVE and sPVE scores
      
      df <- df %>% 
        pivot_wider(names_from = sco, values_from = sco_val)
      cols_to_keep <- c("gene_id", "tPVE", "sPVE")
      
    } else {
      # df contains a single score (all but tPVE + sPVE)
      
      new_colname <- df$sco[1]
      df <- df %>% 
        rename(!!new_colname := sco_val)
      cols_to_keep <- c("gene_id", new_colname)
      
    }
    
    # select gene and score columns
    df <- df %>% 
      select(all_of(cols_to_keep))
    
    # return df
    return(df)
    
  })
  
  # combine all dfs in one df
  df_combined <- as_tibble(reduce(
    dfs, 
    ~ inner_join(.x, .y, by = "gene_id")
  ))
  
  # create df HVGs only
  df_combined_hvg <- df_combined %>% 
    filter(gene_id %in% hvgs)
  
  # return combined df
  return(
    list(
      fss_full = df_combined,
      fss_hvg = df_combined_hvg
    )
  )
  
}
```

### Patches Scores

```{r}
files <- list.files(
  path = "../../data/sim/02-scores_patches/",
  pattern = "\\.csv$", full.names = TRUE,
)

patches_scores <- lapply(files, load_process_patches_scores)
names(patches_scores) <- sub(".*-(.*)_loadings\\.csv", "\\1", basename(files))
```

```{r}
lapply(patches_scores, head)
```

### FSS Scores

```{r}
files <- list.files(
  "../../data/sim/02-scores_fss/",
  pattern = "\\.rds$", 
  full.names = TRUE
)
hvgs <- patches_scores$patches_clu_con_hvg$gene_id

fss_scores <- load_process_fss_scores(files, hvgs)
```

```{r}
lapply(fss_scores, head)
```

### Comparison of Scores

#### Transformation

```{r}
# combine Patches and FSS scores in one df for each Patches workflow
all_scores <- lapply(patches_scores, function(df) {
  
  if (dim(df)[1] == dim(fss_scores$fss_full)[1]) {
    # df contains full data
    
    new_df <- cbind.data.frame(
      df,
      fss_scores$fss_full %>% 
        select(!gene_id)
    )
    
  } else {
    # df contains HVG data
    
    new_df <- cbind.data.frame(
      df,
      fss_scores$fss_hvg %>% 
        select(!gene_id)
    )
    
  }
  
  return(new_df)
  
})

lapply(all_scores, head)
```

```{r}
# add z-transformed scores to make them comparable
all_scores_z <- lapply(all_scores, function(df) {
  
  new_df <- df %>% 
    mutate(
      across(
        .cols = -gene_id,
        .fns = ~ as.numeric(scale(.x)),
        .names = "{.col}_z"
      )
    )
  
  return(new_df)
  
})

lapply(all_scores_z, head)
```

#### Correlation

```{r}
lapply(all_scores_z, function(df) {
  df_z <- df %>% 
    select(ends_with("_z"))
  
  cor_mat <- cor(
    df_z,
    use = "pairwise.complete.obs",
    method = "spearman"
  )
  
  cor_long <- melt(cor_mat)
  
  ggplot(data = cor_long, mapping = aes(Var1, Var2, fill = value)) +
    geom_tile() +
    scale_fill_gradient2(
      low = "blue", mid = "white", high = "red", midpoint = 0,
      limits = c(-1, 1)
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid = element_blank()
    ) +
    labs(x = "", y = "", fill = "Rank\nCorrelation")
  
})
```

#### Scatter Plots

```{r}
# generic function for producing a scatter plot of two scores for all given dfs
plot_scatter <- function(df_list, score1, score2) {
  
  # apply plotting function to all dfs
  lapply(seq_len(length(df_list)), function(i) {
    
    # get df and its name
    df <- df_list[[i]]
    name <- names(df_list)[i]
    
    # if scores are not present, skip df
    if (any(!c(score1, score2) %in% colnames(df))) {
      return(NULL)
    }
    
    # calculate correlation between the two scores
    c <- cor(df[[score1]], df[[score2]], method = "spearman")
    title <- paste(name, "- Rank Correlation:", round(c, 2))
  
    # scatter plot comparing score1 and score2
    ggplot(
      data = df,
      mapping = aes(x = .data[[score1]], y = .data[[score2]])
    ) +
      geom_point() +
      geom_smooth() +
      theme_minimal() +
      labs(
        x = score1, y = score2, 
        title = title
       )
    
  })
  
}
```

```{r}
# tF vs. common score
plot_scatter(all_scores_z, "tF_z", "common_score_Patches_z")
```

```{r}
# tF vs. group max absolute score
plot_scatter(all_scores_z, "tF_z", "group_score_max_abs_Patches_z")
```

```{r}
# tF vs. group Euclidean norm score
plot_scatter(all_scores_z, "tF_z", "group_score_eucl_norm_Patches_z")
```

```{r}
# tPVE vs. common score
plot_scatter(all_scores_z, "tPVE_z", "common_score_Patches_z")
```

```{r}
# tPVE vs. group max absolute score
plot_scatter(all_scores_z, "tPVE_z", "group_score_max_abs_Patches_z")
```

```{r}
# tPVE vs. group Euclidean norm score
plot_scatter(all_scores_z, "tPVE_z", "group_score_eucl_norm_Patches_z")
```

```{r}
# sPBDS vs. condition max absolute score
plot_scatter(all_scores_z, "sPBDS_z", "condition_score_max_abs_Patches_z")
```

```{r}
# sPBDS vs. condition Euclidean norm score
plot_scatter(all_scores_z, "sPBDS_z", "condition_score_eucl_norm_Patches_z")
```

```{r}
# sPVE vs. condition max absolute score
plot_scatter(all_scores_z, "sPVE_z", "condition_score_max_abs_Patches_z")
```

```{r}
# sPVE vs. condition Euclidean norm score
plot_scatter(all_scores_z, "sPVE_z", "condition_score_eucl_norm_Patches_z")
```



## Selection

### Gene Ground Truths (FSS Selections)

Gene ground truths, i.e., whether a gene is considered a type or a state gene, can be obtained from the simulated data via the logFC of splatter's DE factor (e.g., `ConditionDE.Condition1` or `GroupDE.Group1` in gene metadata). A gene is considered DEnotDS if there is a group logFC unequal to 1 and no condition logFC unequal to 1. Similarly, a gene is considered DS if there is a condition logFC unequal to 1, regardless of group logFCs. DEnotDS genes are selected as ground truth type genes, while DS genes are selected for ground truth state genes, i.e., a type gene must have a group effect and no state effect, while a state gene must have a condition effect while a group effect is not necessary (but can exist).

Here, all selections from the FSS paper's workflow are loaded for the t100,s80,b0 experiment and combined. This includes the selection strategies based on simulation parameters (like DEnotDS and DS) as well as selection strategies based on feature scores. 

```{r}
# get all files containing selections
rds_files <- list.files(
  "../../data/sim/03-selections_fss/",
  pattern = "\\.rds$", 
  full.names = TRUE
)

# select gene and selection columns and combine all dfs in one list
fss_selection_dfs <- lapply(rds_files, function(file) {
  
  # get df from file name
  df <- readRDS(file)
  
  # df contains a single selection
  new_colname <- df$sel[1]
  df <- df %>% 
    rename(!!new_colname := sel_val)
  cols_to_keep <- c("gene_id", new_colname)
  
  # select gene and score columns
  df <- df %>% 
    select(all_of(cols_to_keep))
  
})

# combine all dfs in one df
fss_selection_df <- as_tibble(reduce(
  fss_selection_dfs, 
  ~ inner_join(.x, .y, by = "gene_id")
))

# sort columns to put ground truths first
fss_selections_full <- fss_selection_df %>% 
  select(gene_id, DEnotDS, DS, DSnotDE, DEgtDS, DSgtDE, DE, everything())

# create df with only HVGs
fss_selections_hvg <- fss_selections_full %>% 
  filter(gene_id %in% hvgs)

# combine into list
fss_selections <- list(
  fss_full = fss_selections_full,
  fss_hvg = fss_selections_hvg
)

lapply(fss_selections, head)
```

### Patches Selections






































## Comparison 1: Selected Genes and Gene Ground Truths

### Helper Functions

```{r}
# get top n genes for one score
get_top_n_genes <- function(df, score, n) {
  top_genes <- (df %>% 
    arrange(desc(.data[[score]])) %>% 
    slice_head(n = n))$gene_id
  
  return(top_genes)
}

# get top n genes for multiple scores
get_top_n_genes_scores <- function(df, scores, t_or_s, nt, ns) {
  results <- list()
  for (i in 1:length(scores)) {
    score <- scores[i]
    x <- t_or_s[i]
    if (x == "t") {
      results[[score]] <- get_top_n_genes(df, score, nt)
    } else if (x == "s") {
      results[[score]] <- get_top_n_genes(df, score, ns)
    }
  }
  return(results)
}

# get binary predictions for all scores in the selection list
compute_predictions <- function(selection_list, all_genes) {
  df <- data.frame(gene_id = all_genes)
  for (key in ls(selection_list)) {
    df[[key]] <- ifelse(all_genes %in% selection_list[[key]], 1, 0)
  }
  return(df)
}
```

### Gene Ground Truths

```{r}
# get true type genes (DEnotDS)
true_tg_full <- (fss_selections_full %>% 
  filter(DEnotDS == TRUE) %>% 
  select(gene_id))$gene_id

true_tg_hvg <- (fss_selections_hvg %>% 
  filter(DEnotDS == TRUE) %>% 
  select(gene_id))$gene_id

# get number of true type genes
nt_full <- length(true_tg_full)
nt_hvg <- length(true_tg_hvg)

# get true state genes (DS)
true_sg_full <- (fss_selections_full %>% 
  filter(DS == TRUE) %>% 
  select(gene_id))$gene_id

true_sg_hvg <- (fss_selections_hvg %>% 
  filter(DS == TRUE) %>% 
  select(gene_id))$gene_id 

# get the same number of predicted state genes via top-n Patches scores
ns_full <- length(true_sg_full)
ns_hvg <- length(true_sg_hvg)

# get lists of all genes for metric calculations
all_genes_full <- fss_selections_full$gene_id
all_genes_hvg <- fss_selections_hvg$gene_id

# get binary vectors for metric calculations
y_true_tg_full <- as.numeric(fss_selections_full$DEnotDS)
y_true_tg_hvg <- as.numeric(fss_selections_hvg$DEnotDS)

y_true_sg_full <- as.numeric(fss_selections_full$DS)
y_true_sg_hvg <- as.numeric(fss_selections_hvg$DS)
```

### FSS Scores Selections

#### FSS Scores Full

```{r}
# compute the selected genes for each score
scores <- c("tF", "tPVE", "sPBDS", "sPVE")
t_or_s <- c("t", "t", "s", "s")
fss_selections_full <- get_top_n_genes_scores(
  fss_scores_full,
  scores,
  t_or_s,
  nt_full,
  ns_full
)

# turn selected genes into predictions for metric calculation
fss_full_preds <- compute_predictions(fss_full_selections, all_genes_full)
```

```{r}
# add ground truths to list
fss_full_selections$GroundTruthType <- true_tg_full
fss_full_selections$GroundTruthState <- true_sg_full

# type ground truth vs. FSS tF selection
upset(
  fromList(fss_full_selections),
  order.by = "freq",
  sets = c("GroundTruthType", "tF")
)

# type ground truth vs. FSS tPVE selection
upset(
  fromList(fss_full_selections),
  order.by = "freq",
  sets = c("GroundTruthType", "tPVE")
)

# state ground truth vs. FSS sPBDS selection
upset(
  fromList(fss_full_selections),
  order.by = "freq",
  sets = c("GroundTruthState", "sPBDS")
)

# state ground truth vs. FSS sPVE selection
upset(
  fromList(fss_full_selections),
  order.by = "freq",
  sets = c("GroundTruthState", "sPVE")
)
```

#### FSS Scores HVG

```{r}
# compute the selected genes for each score
scores <- c("tF", "tPVE", "sPBDS", "sPVE")
t_or_s <- c("t", "t", "s", "s")
fss_hvg_selections <- get_top_n_genes_scores(
  fss_scores_full,
  scores,
  t_or_s,
  nt_full,
  ns_full
)

# turn selected genes into predictions for metric calculation
fss_full_preds <- compute_predictions(fss_full_selections, all_genes_full)
```

```{r}
# add ground truths to list
fss_full_selections$GroundTruthType <- true_tg_full
fss_full_selections$GroundTruthState <- true_sg_full

# type ground truth vs. FSS tF selection
upset(
  fromList(fss_full_selections),
  order.by = "freq",
  sets = c("GroundTruthType", "tF")
)

# type ground truth vs. FSS tPVE selection
upset(
  fromList(fss_full_selections),
  order.by = "freq",
  sets = c("GroundTruthType", "tPVE")
)

# state ground truth vs. FSS sPBDS selection
upset(
  fromList(fss_full_selections),
  order.by = "freq",
  sets = c("GroundTruthState", "sPBDS")
)

# state ground truth vs. FSS sPVE selection
upset(
  fromList(fss_full_selections),
  order.by = "freq",
  sets = c("GroundTruthState", "sPVE")
)
```

```{r}
# type genes based on tF score
fss_hvg_tg_tF <- get_top_n_genes(
  fss_scores_hvg,
  "tF",
  nt_hvg
)

# type genes based on tPVE score
fss_hvg_tg_tPVE <- get_top_n_genes(
  fss_scores_hvg,
  "tPVE",
  nt_hvg
)

# state genes based on sPBDS score
fss_hvg_sg_sPBDS <- get_top_n_genes(
  fss_scores_hvg,
  "sPBDS",
  ns_hvg
)

# state genes based on sPVE score
fss_hvg_sg_sPVE <- get_top_n_genes(
  fss_scores_hvg,
  "sPVE",
  ns_hvg
)
```

```{r}
# combine all gene sets into one list for plotting
gene_sets_fss_hvg <- list(
  GroundTruthType = true_tg_hvg,
  GroundTruthState = true_sg_hvg,
  tF_HVG = fss_hvg_tg_tF,
  tPVE_HVG = fss_hvg_tg_tPVE,
  sPBDS_HVG = fss_hvg_sg_sPBDS,
  sPVE_HVG = fss_hvg_sg_sPVE
)

# type ground truth vs. FSS tF selection
upset(
  fromList(gene_sets_fss_hvg),
  order.by = "freq",
  sets = c("GroundTruthType", "tF_HVG")
)

# type ground truth vs. FSS tPVE selection
upset(
  fromList(gene_sets_fss_hvg),
  order.by = "freq",
  sets = c("GroundTruthType", "tPVE_HVG")
)

# state ground truth vs. FSS sPBDS selection
upset(
  fromList(gene_sets_fss_hvg),
  order.by = "freq",
  sets = c("GroundTruthState", "sPBDS_HVG")
)

# state ground truth vs. FSS sPVE selection
upset(
  fromList(gene_sets_fss_hvg),
  order.by = "freq",
  sets = c("GroundTruthState", "sPVE_HVG")
)
```

### Patches Scores Selections

#### Full Data + Condtion (State) Only - Workflow1

```{r}
# type genes based on common score
patches_con_full_tg_common <- get_top_n_genes(
  patches_con_full,
  "common_score_Patches",
  nt_full
)

# state genes based on max absolute score
patches_con_full_sg_max_abs <- get_top_n_genes(
  patches_con_full,
  "condition_score_Patches_max_abs",
  ns_full
)

# state genes based on Euclidean norm score
patches_con_full_sg_eucl_norm <- get_top_n_genes(
  patches_con_full,
  "condition_score_Patches_eucl_norm",
  ns_full
)
```

```{r}
# combine all gene sets into one list for plotting
gene_sets_con_full <- list(
  GroundTruthType = true_tg_full,
  GroundTruthState = true_sg_full,
  PatchesConFullCommon = patches_con_full_tg_common,
  PatchesConFullMaxAbs = patches_con_full_sg_max_abs,
  PatchesConFullEuclNorm = patches_con_full_sg_eucl_norm
)

# type ground truth vs. Patches common score selection
upset(
  fromList(gene_sets_con_full),
  order.by = "freq",
  sets = c("GroundTruthType", "PatchesConFullCommon")
)

# state ground truth vs. Patches condition max absolute selection
upset(
  fromList(gene_sets_con_full),
  order.by = "freq",
  sets = c("GroundTruthState", "PatchesConFullMaxAbs")
)

# state ground truth vs. Patches condition Euclidean norm selection
upset(
  fromList(gene_sets_con_full),
  order.by = "freq",
  sets = c("GroundTruthState", "PatchesConFullEuclNorm")
)
```

#### HVG Data + Condtion (State) Only - Workflow2

```{r}
# types genes based on common score
patches_con_hvg_tg_common <- get_top_n_genes(
  patches_con_hvg,
  "common_score_Patches",
  nt_hvg
)

# state genes based on max absolute score
patches_con_hvg_sg_max_abs <- get_top_n_genes(
  patches_con_hvg,
  "condition_score_Patches_max_abs",
  ns_hvg
)

# state genes based on Euclidean norm score
patches_con_hvg_sg_eucl_norm <- get_top_n_genes(
  patches_con_hvg,
  "condition_score_Patches_eucl_norm",
  ns_hvg
)
```

```{r}
# combine all gene sets into one list for plotting
gene_sets_con_hvg <- list(
  GroundTruthType = true_tg_hvg,
  GroundTruthState = true_sg_hvg,
  PatchesConHVGCommon = patches_con_hvg_tg_common,
  PatchesConHVGMaxAbs = patches_con_hvg_sg_max_abs,
  PatchesConHVGEuclNorm = patches_con_hvg_sg_eucl_norm
)

# type ground truth vs. Patches common score selection
upset(
  fromList(gene_sets_con_hvg),
  order.by = "freq",
  sets = c("GroundTruthType", "PatchesConHVGCommon")
)

# state ground truth vs. Patches condition max absolute selection
upset(
  fromList(gene_sets_con_hvg),
  order.by = "freq",
  sets = c("GroundTruthState", "PatchesConHVGMaxAbs")
)

# state ground truth vs. Patches condition Euclidean norm selection
upset(
  fromList(gene_sets_con_hvg),
  order.by = "freq",
  sets = c("GroundTruthState", "PatchesConHVGEuclNorm")
)
```

#### Full Data + Cluster (Type) & Condtion (State) - Workflow3

```{r}
# type genes based on common score
patches_clu_con_full_tg_common <- get_top_n_genes(
  patches_clu_con_full,
  "common_score_Patches",
  nt_full
)

# type genes based on max absolute score
patches_clu_con_full_tg_max_abs <- get_top_n_genes(
  patches_clu_con_full,
  "group_score_Patches_max_abs",
  nt_full
)

# type genes based on Euclidean norm score
patches_clu_con_full_tg_eucl_norm <- get_top_n_genes(
  patches_clu_con_full,
  "group_score_Patches_eucl_norm",
  nt_full
)

# state genes based on max absolute score
patches_clu_con_full_sg_max_abs <- get_top_n_genes(
  patches_clu_con_full,
  "condition_score_Patches_max_abs",
  ns_full
)

# state genes based on Euclidean norm score
patches_clu_con_full_sg_eucl_norm <- get_top_n_genes(
  patches_clu_con_full,
  "condition_score_Patches_eucl_norm",
  ns_full
)
```

```{r}
# combine all gene sets into one list for plotting
gene_sets_clu_con_full <- list(
  GroundTruthType = true_tg_full,
  GroundTruthState = true_sg_full,
  PatchesCluConFullCommon = patches_clu_con_full_tg_common,
  PatchesCluConFullMaxAbsType = patches_clu_con_full_tg_max_abs,
  PatchesCluConFullEuclNormType = patches_clu_con_full_tg_eucl_norm,
  PatchesCluConFullMaxAbsState = patches_clu_con_full_sg_max_abs,
  PatchesCluConFullEuclNormState = patches_clu_con_full_sg_eucl_norm
)

# type ground truth vs. Patches common score selection
upset(
  fromList(gene_sets_clu_con_full),
  order.by = "freq",
  sets = c("GroundTruthType", "PatchesCluConFullCommon")
)

# type ground truth vs. Patches group max absolute selection
upset(
  fromList(gene_sets_clu_con_full),
  order.by = "freq",
  sets = c("GroundTruthType", "PatchesCluConFullMaxAbsType")
)

# type ground truth vs. Patches group Euclidean norm selection
upset(
  fromList(gene_sets_clu_con_full),
  order.by = "freq",
  sets = c("GroundTruthType", "PatchesCluConFullEuclNormType")
)

# state ground truth vs. Patches condition max absolute selection
upset(
  fromList(gene_sets_clu_con_full),
  order.by = "freq",
  sets = c("GroundTruthState", "PatchesCluConFullMaxAbsState")
)

# state ground truth vs. Patches condition Euclidean norm selection
upset(
  fromList(gene_sets_clu_con_full),
  order.by = "freq",
  sets = c("GroundTruthState", "PatchesCluConFullEuclNormState")
)
```

#### HVG Data + Cluster (Type) & Condtion (State) - Workflow4

```{r}
# type genes based on common score
patches_clu_con_hvg_tg_common <- get_top_n_genes(
  patches_clu_con_hvg,
  "common_score_Patches",
  nt_hvg
)

# type genes based on max absolute score
patches_clu_con_hvg_tg_max_abs <- get_top_n_genes(
  patches_clu_con_hvg,
  "group_score_Patches_max_abs",
  nt_hvg
)

# type genes based on Euclidean norm score
patches_clu_con_hvg_tg_eucl_norm <- get_top_n_genes(
  patches_clu_con_hvg,
  "group_score_Patches_eucl_norm",
  nt_hvg
)

# state genes based on max absolute score
patches_clu_con_hvg_sg_max_abs <- get_top_n_genes(
  patches_clu_con_hvg,
  "condition_score_Patches_max_abs",
  ns_hvg
)

# state genes based on Euclidean norm score
patches_clu_con_hvg_sg_eucl_norm <- get_top_n_genes(
  patches_clu_con_hvg,
  "condition_score_Patches_eucl_norm",
  ns_hvg
)
```

```{r}
# combine all gene sets into one list for plotting
gene_sets_clu_con_hvg <- list(
  GroundTruthType = true_tg_hvg,
  GroundTruthState = true_sg_hvg,
  PatchesCluConHVGCommon = patches_clu_con_hvg_tg_common,
  PatchesCluConHVGMaxAbsType = patches_clu_con_hvg_tg_max_abs,
  PatchesCluConHVGEuclNormType = patches_clu_con_hvg_tg_eucl_norm,
  PatchesCluConHVGMaxAbsState = patches_clu_con_hvg_sg_max_abs,
  PatchesCluConHVGEuclNormState = patches_clu_con_hvg_sg_eucl_norm
)

# type ground truth vs. Patches common score selection
upset(
  fromList(gene_sets_clu_con_hvg),
  order.by = "freq",
  sets = c("GroundTruthType", "PatchesCluConHVGCommon")
)

# type ground truth vs. Patches group max absolute selection
upset(
  fromList(gene_sets_clu_con_hvg),
  order.by = "freq",
  sets = c("GroundTruthType", "PatchesCluConHVGMaxAbsType")
)

# type ground truth vs. Patches group Euclidean norm selection
upset(
  fromList(gene_sets_clu_con_hvg),
  order.by = "freq",
  sets = c("GroundTruthType", "PatchesCluConHVGEuclNormType")
)

# state ground truth vs. Patches condition max absolute selection
upset(
  fromList(gene_sets_clu_con_hvg),
  order.by = "freq",
  sets = c("GroundTruthState", "PatchesCluConHVGMaxAbsState")
)

# state ground truth vs. Patches condition Euclidean norm selection
upset(
  fromList(gene_sets_clu_con_hvg),
  order.by = "freq",
  sets = c("GroundTruthState", "PatchesCluConHVGEuclNormState")
)
```












### Type Genes

```{r}
# get true type genes
true_tg <- (fss_selections %>% 
  filter(DEnotDS == TRUE) %>% 
  select(gene_id))$gene_id

# get the same number of predicted type genes via top-n Patches scores
nt <- length(true_tg)

t_abs <- rank(patches_clu_con$group_score_Patches_max_abs)
o_abs <- order(t_abs, decreasing = TRUE)
patches_tg_abs <- patches_clu_con$gene_id[o_abs[seq_len(nt)]]

t_eucl <- rank(patches_clu_con$group_score_Patches_eucl_norm)
o_eucl <- order(t_eucl, decreasing = TRUE)
patches_tg_eucl <- patches_clu_con$gene_id[o_eucl[seq_len(nt)]]

# compare overlap
gene_sets <- list(
  GroundTruth = true_tg,
  PatchesMaxAbs = patches_tg_abs,
  PatchesEuclNorm = patches_tg_eucl
)

upset(fromList(gene_sets),
      order.by = "freq",
      sets = c("GroundTruth", "PatchesMaxAbs"))
upset(fromList(gene_sets),
      order.by = "freq",
      sets = c("GroundTruth", "PatchesEuclNorm"))
```

### State Genes

```{r}
# get true state genes
true_sg <- (fss_selections %>% 
  filter(DS == TRUE) %>% 
  select(gene_id))$gene_id

# get the same number of predicted state genes via top-n Patches scores
nt <- length(true_sg)

t_abs <- rank(patches_clu_con$condition_score_Patches_max_abs)
o_abs <- order(t_abs, decreasing = TRUE)
patches_sg_abs <- patches_clu_con$gene_id[o_abs[seq_len(nt)]]

t_eucl <- rank(patches_clu_con$condition_score_Patches_eucl_norm)
o_eucl <- order(t_eucl, decreasing = TRUE)
patches_sg_eucl <- patches_clu_con$gene_id[o_eucl[seq_len(nt)]]

# compare overlap
gene_sets <- list(
  GroundTruth = true_sg,
  PatchesMaxAbs = patches_sg_abs,
  PatchesEuclNorm = patches_sg_eucl
)

upset(fromList(gene_sets),
      order.by = "freq",
      sets = c("GroundTruth", "PatchesMaxAbs"))
upset(fromList(gene_sets),
      order.by = "freq",
      sets = c("GroundTruth", "PatchesEuclNorm"))
```


















































